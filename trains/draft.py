"""

----------------------------------------- ForeignKey ---------------------------------------
аттрибу on_delete для ForeignKey

on_delete=CASCADE - говорит о том, что все записи будут удаляться каскадом,
т.е. если из главной таблицы удалить запись, то все записи, которые на нее ссылаются будут удалены

on_delete=PROTECT - говорит о том, что запись не может быть удалена, если на нее ссылается хоть одна запись
в другой таблице

on_delete=SET_DEFAULT - даёт возможность задать запись по умолчанию

on_delete=SET_NULL - задаёт NULL для всех дочерних записей, при удалении родительских
но чтобы задать SET_NULL нужно в определении этого поля задать также blank=True, null=True

    blank=True - говорит, что это поле можно не заполнять, когда мы создаём какую-то строчку
    null=True - говорит о том, что это поле может быть пустым, там может быть ничего



"""




# ------------------------------------ Отличный алгоритм для DFS (графы) ----------------------------------
graph1 = {
    'A': {'B', 'S'},
    'B': {'A'},
    'C': {'D', 'E', 'F', 'S'},
    'D': {'C'},
    'E': {'C', 'H'},
    'F': {'C', 'G'},
    'G': {'F', 'S'},
    'H': {'E', 'G'},
    'S': {'A', 'C', 'G'}
}


def dfs_paths(graph, start, goal):
    stack = [(start, [start, ])]
    while stack:
        (vertex, path) = stack.pop()
        if vertex in graph.keys():
            for next_ in graph[vertex] - set(path):
                if next_ == goal:
                    yield path + [next_]
                else:
                    stack.append((next_, path + [next_, ]))


f = dfs_paths(graph1, 'A', 'F')
print(f.__next__())                             # ['A', 'S', 'C', 'F']
print(dfs_paths(graph1, 'A', 'F').__next__())   # ['A', 'S', 'C', 'F']
print(list(dfs_paths(graph1, 'A', 'F')))        # [['A', 'S', 'C', 'F'], ['A', 'S', 'C', 'E', 'H', 'G', 'F'], ['A', 'S', 'G', 'F']]
print(f)                                        # <generator object dfs_path at 0x7f92a5d6bf90>

print(range(1,4), type(range(1,4)))             # range(1, 4) <class 'range'>
print(list(range(1,4)))                         # [1, 2, 3]

# ---------------------------------------------------------------------------------------------------

# ----- О ФОРМАХ
# Когда мы определяем модельную форму заимствованную от ModelForm
# мы позволяем django самому формировать поля формы, основываясь на модели
# к которой мы эту модельную форму привязали
# Но только не в том случае, когда мы переопределяем какое-то поле
# для этой модельной формы
# тогда мы меняем механизм формирования данного поля
# как доказательство, что мы меня механизм переопределения
# label в html шаблоне будет браться тот, что указан в поле модели если не переопределяем
# и указан тот что будет в переопределенном поле (или название поля если label как арумент не указываем)
# если переопределяем соответственно

# но все равно это поле должно соответствовать типу данных поля соответствующей модели

# class CityModelForm(ModelForm):
#     name = CharField(label='Город', widget=TextInput(attrs={'class': ' form-control',
#                                                             'placeholder': 'введите название города', }))
#     class Meta:
#         model = City
#         fields = ('name',)







